import Acmoi.HydePrelim
import Mathlib.Tactic.Ring
import Mathlib.Tactic.LinArith
/-!
  # Hyde's Theorem
-/

open Finset Fintype Nat Classical

/-- The transition function δ generated by a labeled path.
δ b r = {s | s is reachable in one step from r reading b}.
-/
def δ_of_path {A Q : Type*} {n : ℕ} (w : Fin n → A)
    (p : Fin (n+1) → Q) (b : A) (r : Q) :=
  {s | ∃ t : Fin n,
    p t.castSucc = r ∧ p t.succ = s ∧ w t = b}

/-- Kayleigh Hyde's transition function δ. -/
def khδ' {A : Type*} {k : ℕ} (w : Fin (2*k+1) → A) :
    A → Fin (k+1) → Set (Fin (k+1)) :=
  δ_of_path w fun t =>
    dite (t.1 < k + 1) (⟨t.1, .⟩)
    (⟨2 * k + 1 - t.1, flipCast .⟩)

def moves_slowly {k : ℕ} (p : Fin (2 * k + 1 + 1) → Fin (k + 1)) : Prop :=
  ∀ s : Fin (2 * k + 1), (p s.succ).1 ≤ (p s.castSucc).1 + 1

/-- If a Kayleigh graph accepts a word then it never advances by more than one.
NOTE: More is true, it is sufficient that ``khδ'` *process* the word. -/
theorem khδ_moves_slowly {A : Type*} {k : ℕ} {w : Fin (2 * k + 1) → A}
    {p : Fin (2 * k + 1 + 1) → Fin (k + 1)}
    {final : Fin (k+1)}
    (h : accepts_path (khδ' w) 0 final p) : moves_slowly p := by
  intro s
  unfold khδ' accepts_path at h
  have := h.2.2 s
  obtain ⟨a,ha⟩ := this
  simp only [δ_of_path, Fin.coe_eq_castSucc, Fin.coe_castSucc, Fin.val_succ,
    add_lt_add_iff_right, reduceSubDiff, Set.mem_setOf_eq] at ha
  obtain ⟨t,ht⟩ := ha
  by_cases h₀ : t.1 < k + 1
  · rw [dif_pos h₀] at ht
    by_cases h₁ : t.1 < k
    · rw [dif_pos h₁] at ht
      rw [← ht.1, ← ht.2.1]
    · rw [dif_neg h₁] at ht
      rw [← ht.1, ← ht.2.1]
      simp only [tsub_le_iff_right, ge_iff_le]
      omega
  · rw [dif_neg h₀] at ht
    have h₁ : ¬ t.1 < k := by omega
    rw [dif_neg h₁] at ht
    rw [← ht.1, ← ht.2.1]
    simp only [tsub_le_iff_right, ge_iff_le]
    omega



theorem idBound_of_moves_slowly {k : ℕ}
    {p : Fin (2 * k + 1 + 1) → Fin (k + 1)}
    (h : p 0 = 0)
    (h₀ : moves_slowly p)
    :
    ∀ s : Fin (2*k+1+1), (p s).1 ≤ s.1 := by
  intro s
  exact @Fin.induction (2*k+1) (fun n => (p n).1 ≤ n.1)
    (by simp;rw [h];simp) (by
      intro n ih
      calc
      _ ≤ (p (n.castSucc)).1 + 1 := h₀ _
      _ ≤ n.castSucc + 1         := add_le_add_right ih 1
      _ ≤ _                      := le_refl (↑n.castSucc + 1)
    ) s

/-- If a Kayleigh graph accepts a word then its position is dominated by the
 identity. -/
theorem kayleighBound {A : Type*} {k : ℕ} {w : Fin (2 * k + 1) → A}
    {p : Fin (2 * k + 1 + 1) → Fin (k + 1)} (h : accepts_path (khδ' w) 0 0 p) :
    ∀ s : Fin (2*k+1+1), (p s).1 ≤ s.1 :=
  idBound_of_moves_slowly h.1 <| khδ_moves_slowly h

def retreatSlow {k : ℕ} (p : Fin (2 * k + 1 + 1) → Fin (k + 1)) :=
    ∀ (s : Fin (2 * k + 1)), (p s.succ).1 ≥ (p s.castSucc).1 - 1

/-- A Kayleigh graph path does not retreat too fast. -/
theorem kayleighBound_lower {A : Type*} {k : ℕ} (w : Fin (2 * k + 1) → A)
    (p : Fin (2 * k + 1 + 1) → Fin (k + 1)) (h : accepts_path (khδ' w) 0 0 p) :
    retreatSlow p :=
  fun s => @Fin.induction (2 * k)
    (fun n => (p n.castSucc).1 - 1 ≤ (p n.succ).1)
    (by
      simp only [Fin.castSucc_zero, Fin.succ_zero_eq_one, tsub_le_iff_right]
      rw [h.1]; simp)
    (by
      intro n hn
      obtain ⟨a,ha⟩ := h.2.2 n.succ
      simp only [khδ', δ_of_path, Fin.coe_eq_castSucc, Fin.coe_castSucc,
        Fin.val_succ, add_lt_add_iff_right, reduceSubDiff, Set.mem_setOf_eq] at ha
      obtain ⟨t,ht⟩ := ha
      by_cases h₀ : t.1 < k + 1
      · rw [dif_pos h₀] at ht
        by_cases h₁ : t.1 < k
        · rw [dif_pos h₁] at ht
          rw [← ht.1, ← ht.2.1]
          simp only [tsub_le_iff_right]
          omega
        · rw [dif_neg h₁] at ht
          rw [← ht.1, ← ht.2.1]
          simp only [tsub_le_iff_right]
          omega
      · have h₁ : ¬ t.1 < k := by omega
        rw [dif_neg h₀, dif_neg h₁] at ht
        rw [← ht.1, ← ht.2.1]
        simp only [tsub_le_iff_right, ge_iff_le]
        omega
    ) s

theorem loop_when_of_retreat_slow {k : ℕ} (p : Fin (2 * (k + 1)) → Fin (k + 1))
    {t : Fin (2 * k + 1)} (ht : p t.castSucc = Fin.last k ∧ p t.succ = Fin.last k)
    (h₀ : p 0 = 0) (h₁ : retreatSlow p)
    (h₂ : moves_slowly p) (h₃ : p (Fin.last (2*k+1)) = 0) :
    t = ⟨k, by omega⟩ := by
  by_contra H
  have (s : Fin (2 * k+1 - t.1)): (p (⟨t.1 + 1 + s, by omega⟩)).1 ≥ k - s :=
    @Fin.induction (2*k-t.1)
      (fun n : Fin (2*k-t.1+1) =>
        (p (⟨t.1 + 1 + n, by omega⟩)).1 ≥ k - n)
        (le_of_eq <| Fin.mk.inj_iff.mp ht.2.symm) (by
        intro i hi
        have h₁ := h₁ ⟨t.1 + 1 + i.1, by omega⟩
        simp_all only [mul_eq, gt_iff_lt, Fin.is_lt, ge_iff_le,
          tsub_le_iff_right, Fin.coe_castSucc, Fin.succ_mk, Fin.castSucc_mk,
          Fin.val_succ]
        simp_rw [← add_assoc (t.1 + 1)]
        omega
      ) ⟨s.1, by omega⟩
  have h₃ := this ⟨2*k+1-(t.1+1), by omega⟩
  simp only [reduceSubDiff, ge_iff_le, tsub_le_iff_right] at h₃
  have h₁ : (p t.castSucc).1 ≤ t.castSucc := idBound_of_moves_slowly h₀ h₂ _
  simp only [Fin.coe_castSucc] at h₁
  cases lt_or_gt_of_ne fun hc => H <| Fin.eq_mk_iff_val_eq.mpr hc with
  | inl h' =>
    have : (p t.castSucc).1 < k := calc _ ≤ _ := h₁
                                        _ < _ := h'
    rw [ht.1] at this
    simp at this
  | inr _ =>
    have h₀ : 1 ≤ (p ⟨t.1 + 1 + (2 * k - t.1), by omega⟩).1 := by omega
    have h₁ : t.1 + 1 + (2 * k - t.1) = 2*k+1 := by omega
    simp_rw [h₁] at h₀
    change 1 ≤ (p (Fin.last (2*k+1))).1 at h₀
    simp_all


/-- If the Kayleigh graph ever uses the loop, we know when!
Same proof for khδ' as for khδ given earlier lemmas, so we could
generalize this.
-/
theorem hyde_loop_when {A : Type*} {k : ℕ} (w : Fin (2 * k + 1) → A)
    (p : Fin (2 * (k + 1)) → Fin (k + 1))
    (h : accepts_path (khδ' w) 0 0 p) (t : Fin (2 * k + 1))
    (ht : p t.castSucc = Fin.last k ∧ p t.succ = Fin.last k) :
    t = ⟨k, by omega⟩ :=
  loop_when_of_retreat_slow _ ht h.1 (kayleighBound_lower w p h)
    (khδ_moves_slowly h) h.2.1

theorem general_parity {k : ℕ} {p : Fin (2 * (k + 1)) → Fin (k + 1)}
    (h₀ : p 0 = 0) (h₁ : retreatSlow p)
    (h₂ : moves_slowly p)
    (h₄ : ∀ i : Fin (2*k+1), p i.succ ≠ p i.castSucc) (t : Fin (2 * (k + 1))) :
    (p t).1 % 2 = t % 2 :=
  @Fin.induction (2*k+1) (fun n => (p n).1 % 2 = n % 2)
    (by simp;rw [h₀];simp) (by
    intro n ih
    have : (p n.succ).1  = (p n.castSucc).1 + 1
      ∨ (p n.succ).1 + 1 = (p n.castSucc).1 := by
      cases lt_or_gt_of_ne <| h₄ n with
      | inl h =>
        right
        have := h₁ n
        omega
      | inr h =>
        left
        have := h₂ n
        omega
    cases this with
    | inl h =>
      rw [h, add_mod_eq_add_mod_right 1 ih]
      simp
    | inr h =>
      have := add_mod_eq_add_mod_right 1 ih
      simp at this ⊢
      rw [← this, ← h, add_assoc]
      symm
      exact add_mod_right (↑(p n.succ)) 2
    ) t

theorem khδ_not_still.{u_1} {A : Type u_1} {k : ℕ}
    {w : Fin (2 * k + 1) → A} {p : Fin (2 * (k + 1)) → Fin (k + 1)}
    (h : accepts_path (khδ' w) 0 0 p) (i : Fin (2*k+1))
    (hi : p i.succ = p i.castSucc) :
    p i.succ = Fin.last k := by
  obtain ⟨a,ha⟩ := h.2.2 i
  obtain ⟨t,ht⟩ := ha
  simp at ht
  split_ifs at ht
  · rw [← ht.2.1] at hi
    rw [← ht.1] at hi
    simp at hi
  · have : t.1 = k := by omega
    rw [← ht.2.1]
    congr
    omega
  · omega
  · rw [← ht.2.1] at hi
    rw [← ht.1] at hi
    simp at hi
    omega


/-- If a Kayleigh graph path never uses the loop, then it preserves parity. -/
theorem hyde_parity {A : Type*} {k : ℕ} {w : Fin (2 * k + 1) → A} {p : Fin (2 * (k + 1)) → Fin (k + 1)}
    (h : accepts_path (khδ' w) 0 0 p)
    (H : ¬ ∃ t : Fin (2*k+1), p t.castSucc = Fin.last k ∧ p t.succ = Fin.last k) :
    ∀ (t : Fin (2 * (k + 1))), (p t).1 % 2 = t % 2 :=
  general_parity h.1 (kayleighBound_lower w p h) (khδ_moves_slowly h)
  (fun i hc => H <| by
    use i
    have h₀ := khδ_not_still h i hc
    exact ⟨hc.symm.trans h₀, h₀⟩
  )



/-- An auxiliary lemma about slow-retreating paths. -/
theorem move_slowly_rev_aux' {k : ℕ} (p : Fin (2 * (k + 1)) → Fin (k + 1))
    (h : retreatSlow p) (s : Fin k) :
    k ≤ k - (p ⟨s.1 + k + 1, by omega⟩).1 + 1
          + (p ⟨s.1 + 1 + k + 1, by omega⟩).1 := by
  suffices k ≤ k + 1 + (p ⟨s + 1 + k + 1, by omega⟩).1
                     - (p ⟨s + k + 1, by omega⟩).1 by omega
  simp_rw [show s + 1 + k + 1 = s + k + 1 + 1 by ring]
  have hmo' := h ⟨s+k+1, by omega⟩

  simp only [Fin.succ_mk, Fin.castSucc_mk, ge_iff_le, tsub_le_iff_right] at hmo'
  have h : k + (1 + (p ⟨s + k + 1 + 1, by omega⟩).1 - (p ⟨s + k + 1, by omega⟩).1)
    = k + 1 + (p ⟨s + k + 1 + 1, by omega⟩).1 - (p ⟨s + k + 1, by omega⟩).1 := by
    apply Nat.eq_sub_of_add_eq'

    omega
  rw [← h]
  apply Nat.le_add_right


/- general: if a path moves slowly, retreats slowly,
 never stands still except at k,
 and goes from 0 to 0 in odd time, then we know what the path is.
-/
theorem general_unique_path {k : ℕ}
  (p : Fin (2*(k+1)) → Fin (k+1))
  (h₀ : p 0 = 0)
  (h₁ : p (Fin.last (2*k+1)) = 0)
  (h₂ : moves_slowly p)
  (h₃ : retreatSlow p)
  (h₄ : ∀ (i : Fin (2 * k + 1)), p i.succ = p i.castSucc → p i.succ = Fin.last k) :
  p = fun t : Fin (2*(k+1)) => dite (t.1 < k + 1) (⟨t.1, .⟩)
    (⟨2*k+1-t.1, flipCast .⟩) := by
  by_cases H : ∃ t : Fin (2*k+1),
    p t.castSucc = Fin.last k ∧ p t.succ = Fin.last k -- we use the loop
  · obtain ⟨t,ht⟩ := H
    have : t = ⟨k,by omega⟩ := loop_when_of_retreat_slow _ ht h₀ h₃ h₂ h₁
    ext s
    split_ifs with g₀
    · by_cases hh : s.1 = k
      · have : s = ⟨k, by omega⟩ := Fin.eq_of_val_eq hh
        aesop
      have h₀':= @exact_racecar k (fun x => p ⟨x.1,by have := x.2;linarith⟩)
        h₀ (by aesop)
        (by
          simp
          unfold moves_slowly at h₂
          intro s
          have := h₂ ⟨s,by omega⟩
          tauto
        ) ⟨s, by omega⟩
      simp only [Fin.castSucc_mk, Fin.eta] at h₀'
      rw [h₀']
    · -- the same as the other case but in opposite order...
      rw [this] at ht
      simp only [not_lt] at g₀
      by_cases hh : s.1 = 2 * k + 1
      · simp_rw [hh]
        simp only [Nat.sub_self]
        have h₀ : s = Fin.last (2*k+1) := Fin.eq_of_val_eq hh
        rw [h₀, h₁]
        simp
      · let f : Fin ((k+1)) → Fin ((k+1)) :=
          fun u  => ⟨k - (p ⟨u + k + 1,by omega⟩).1, by omega⟩
        simp only
        suffices (f ⟨s.1 - (k+1),by omega⟩).1 = s.1 - (k+1) by
          have h₀ : s.1 - (k+1) + k + 1 = s.1 := by omega
          simp_rw [h₀] at this
          change k - (p s).1 = s.1 - (k+1) at this
          omega
        have hf : f (Fin.last k) = Fin.last k := by
          simp only [f, Fin.val_last]
          simp_rw [← two_mul]
          apply Fin.mk.inj_iff.mpr
          show k - (p (Fin.last (2*k+1))).1 = k
          rw [h₁]
          simp
        have := @exact_racecar k f (by simp_all [f]) hf (by
            intro s₁
            rw [tsub_le_iff_right]
            apply move_slowly_rev_aux' _ h₃
          ) ⟨s - (k+1), by omega⟩
        simp only [f, Fin.castSucc_mk, Fin.mk.injEq] at this
        exact this
  · have := @general_parity k p h₀ h₃ h₂ (by aesop) (Fin.last (2*k+1))
    rw [h₁] at this
    simp at this
    omega


/-- The Kayleigh graph NFA for an odd-length word `w` accepts along only the
 intended path. -/
theorem hyde_unique_path {A : Type*} {k : ℕ} (w : Fin (2*k+1) → A)
    (p : Fin (2*(k+1)) → Fin (k+1)) (h : accepts_path (khδ' w) 0 0 p) :
    p = fun t : Fin (2*(k+1)) => dite (t.1 < k + 1) (⟨t.1, .⟩) (⟨2*k+1-t.1, flipCast .⟩)  :=
  general_unique_path _ h.1 h.2.1
    (khδ_moves_slowly h) (kayleighBound_lower w p h) <| khδ_not_still h

/-- The Kayleigh graph NFA for an odd-length word `w` accepts along only the
 intended path, no matter what word `v` with `|v| = |w|` is read. -/
theorem hyde_unique_path_reading_word' {A : Type*} {k : ℕ} {w v : Fin (2*k+1) → A}
  {p : Fin (2*(k+1)) → Fin (k+1)}
  (h : accepts_word_path (khδ' w) v 0 0 p) :
  p = fun t => dite (t.1 < k + 1) (⟨t.1, . ⟩) (⟨2*k+1-t.1,flipCast .⟩)  := by
  apply hyde_unique_path
  apply accepts_path_of_accepts_word_path <;> tauto

/-- The Kayleigh graph NFA for `w` accepts no word of length `|w|` other than
 `w`. -/
theorem hyde_unique_word' {A : Type*} {k : ℕ} {w v : Fin (2*k+1) → A}
    {p : Fin (2*(k+1)) → Fin (k+1)}
    (ha : accepts_word_path (khδ' w) v 0 0 p) :
    w = v := by
  ext ⟨i,hi⟩
  have hup := hyde_unique_path_reading_word' ha
  subst hup
  unfold accepts_word_path khδ' δ_of_path at ha
  simp only [Fin.val_zero, lt_add_iff_pos_left, add_pos_iff, zero_lt_one,
    or_true, ↓reduceDIte, Fin.zero_eta, Fin.val_last, add_lt_add_iff_right,
    Nat.sub_self, dite_eq_right_iff, Fin.coe_eq_castSucc, Fin.coe_castSucc,
    Fin.val_succ, reduceSubDiff, Set.mem_setOf_eq, true_and] at ha
  have h₂ := ha.2 ⟨i, hi⟩
  clear ha
  obtain ⟨t,ht⟩ := h₂
  split_ifs at ht with g₀ g₁
  repeat exact (show i = t.1 by aesop) ▸ ht.2.2
  · have this : i = t.1 := by
      have := ht.2.1
      simp only [Fin.mk.injEq, add_left_inj] at this
      rw [this]
    exact this ▸ ht.2.2
  · have : i = k := by
      simp_all only [Fin.mk.injEq]
      omega
    subst this
    have := ht.1
    simp only [Fin.mk.injEq] at this
    omega
  · omega
  · have : 2 * k - t = 2 * k - i := by
      have := ht.2.1
      simp only [Fin.mk.injEq] at this
      exact this
    simp only [not_lt] at g₁
    omega
  · exact (show i = t.1 by omega) ▸ ht.2.2
  · have : i = k := by omega
    subst this
    have := ht.1
    omega
  · simp only [Fin.mk.injEq] at ht
    omega
  · simp only [Fin.mk.injEq] at ht
    omega
  · exact (show i = t.1 by omega) ▸ ht.2.2
  · omega
  · omega
  · simp only [Fin.mk.injEq, not_lt] at ht
    exact (show i = t.1 by omega) ▸ ht.2.2



/-- δ_of_path works as intended. -/
theorem δ_of_path_works_as_intended' {A Q : Type*} {n : ℕ} (w : Fin n → A)
    (p : Fin (n+1) → Q) :
    (accepts_word_path (δ_of_path w p) w (p 0) (p (Fin.last n)) p) := by
  exact ⟨rfl, ⟨rfl, fun i => ⟨i, rfl,rfl,rfl⟩⟩⟩

/- The Kayleigh graph NFA for `w` accepts `w` along the intended path. -/
theorem hyde_accepts {A : Type*} {k : ℕ}  (w : Fin (2*k+1) → A) :
    accepts_word_path (khδ' w) w 0 0 fun t =>
      dite (t.1 < k + 1) (⟨t.1, .⟩) (⟨2*k+1-t.1,flipCast .⟩) := by
  have := @δ_of_path_works_as_intended' A (Fin (k+1)) (2*k+1) w
    fun t => dite (t.1 < k + 1)
      (fun ht => (⟨t.1, ht⟩ : Fin (k+1))) (fun ht => ⟨2*k+1-t.1,flipCast ht⟩)
  simp [khδ'] at this
  revert this
  apply Iff.mp
  apply Eq.to_iff
  congr
  simp
  omega



/-- Hyde's theorem for odd-length words. -/
theorem hydetheorem_odd' {A : Type*} {k : ℕ} (w : Fin (2*k+1) → A) :
 A_N_at_most w (k+1) := by
 use Fin (k+1), Fin.fintype (k + 1)
 constructor
 · exact Fintype.card_fin (k + 1)
 · use khδ' w, 0, 0, fun t : Fin (2*(k+1)) => dite (t.1 < k + 1)
    (fun ht => (⟨t.1,     ht⟩ : Fin (k+1)))
    (fun ht => (⟨2*k+1-t.1,flipCast ht⟩ : Fin (k+1)))
   constructor
   · exact hyde_accepts w
   · exact fun _ _ h => ⟨(hyde_unique_path_reading_word' h).symm,
                          hyde_unique_word' h⟩


/-- Hyde's theorem for positive-length words. -/
theorem hyde_pos_length {A : Type*} {n : ℕ} (hn : n ≠ 0) (w : Fin n → A) :
A_N_at_most w (n/2+1) := by
  by_cases he : Odd n
  · obtain ⟨k,hk⟩ := he
    subst hk
    have h₀ : (2 * k + 1) / 2 + 1 = k + 1 := by omega
    exact h₀ ▸ hydetheorem_odd' _
  · simp only [not_odd_iff_even] at he
    obtain ⟨k, hk⟩ := he
    rw [← two_mul] at hk
    subst hk
    have h₁ : (2 * k)/2 + 1 = k + 1 := by omega
    rw [h₁]
    have a := (Classical.inhabited_of_nonempty
      <| Nonempty.intro <| w ⟨0, zero_lt_of_ne_zero hn⟩).default
    let w' := @Fin.snoc (2*k) (fun _ => A) w a
    exact (Fin.init_snoc _ _) ▸ restricting <| hydetheorem_odd' w'

/-- Hyde's theorem in relational form. -/
theorem hyde_all_lengths {A : Type*} {n : ℕ} (w : Fin n → A) :
    A_N_at_most w (n/2+1) := by
  by_cases H : n = 0
  · subst H
    exact hyde_emp w
  · exact hyde_pos_length H w

/-- A_N is well-defined. -/
theorem A_N_bounded {A : Type*} {n : ℕ} (w : Fin n → A) :
  ∃ q, A_N_at_most w q := by
  use n/2+1
  apply hyde_all_lengths

/-- Nondeterministic automatic complexity. -/
noncomputable def A_N {A : Type*} : {n : ℕ} → (Fin n → A) → ℕ :=
  fun w => Nat.find (A_N_bounded w)

/-- Hyde's theorem (2013). -/
theorem A_N_bound {A : Type*} {n : ℕ} (w : Fin n → A) :
  A_N w ≤ n/2+1 := find_le <| hyde_all_lengths w
-- end of Hyde


theorem A_Ne_bounded {A : Type} {n : ℕ} (w : Fin n → A) :
  ∃ q, A_Ne_at_most w q := by
  use n/2+1
  exact A_Ne_le_A_N <| hyde_all_lengths w

/-- Exact nondeterministic automatic complexity. -/
noncomputable def A_Ne {A : Type} : {n : ℕ} → (Fin n → A) → ℕ :=
  fun w => Nat.find (A_Ne_bounded w)
