import Mathlib.NumberTheory.Padics.PadicNumbers
import Mathlib.Algebra.Order.Floor
import Mathlib.Data.Nat.Log
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Fin.Tuple.Take
import Acmoi.HydePrelim
set_option maxHeartbeats 2000000
/-!
  # Hyde's Theorem
-/

open Finset Fintype Nat Classical

/-- The transition function δ generated by a labeled path.
δ b r = {s | s is reachable in one step from r reading b}.
-/
def δ_of_path {A Q : Type*} {n : ℕ} (w : Fin n → A) (p : Fin (n+1) → Q) : A → Q → Set Q :=
  fun b r => {s | ∃ t : Fin n, p t.castSucc = r ∧ p t.succ = s ∧ w t = b}

/-- Kayleigh Hyde's "Kayleigh graph" transition function δ. -/
def khδ' {A : Type*} {k : ℕ} (w : Fin (2*k+1) → A) : A → Fin (k+1) → Set (Fin (k+1)) :=
  δ_of_path w fun t => dite (t.1 < k + 1) (⟨t.1, .⟩) (⟨2*k+1-t.1, flipCast .⟩)

/-- If a Kayleigh graph accepts a word then it never advances by more than one.
NOTE: More is true, it is sufficient that ``khδ'` *process* the word. -/
theorem move_slowly {A : Type*} {k : ℕ} {w : Fin (2 * k + 1) → A}
    {p : Fin (2 * k + 1 + 1) → Fin (k + 1)}
    {final : Fin (k+1)}
    (h : accepts_path (khδ' w) 0 final p)
    (s : Fin (2 * k + 1)) :
    (p s.succ).1 ≤ (p s.castSucc).1 + 1 := by
  unfold khδ' accepts_path at h
  have := h.2.2 s
  obtain ⟨a,ha⟩ := this
  unfold δ_of_path at ha
  simp only [Fin.coe_eq_castSucc, Fin.coe_castSucc, Fin.val_succ, add_lt_add_iff_right,
    reduceSubDiff, Set.mem_setOf_eq] at ha
  obtain ⟨t,ht⟩ := ha
  by_cases h₀ : t.1 < k + 1
  · rw [dif_pos h₀] at ht
    by_cases h₁ : t.1 < k
    · rw [dif_pos h₁] at ht
      rw [← ht.1, ← ht.2.1]
    · rw [dif_neg h₁] at ht
      rw [← ht.1, ← ht.2.1]
      simp only [tsub_le_iff_right, ge_iff_le]
      omega
  · rw [dif_neg h₀] at ht
    have h₁ : ¬ t.1 < k := by omega
    rw [dif_neg h₁] at ht
    rw [← ht.1, ← ht.2.1]
    simp only [tsub_le_iff_right, ge_iff_le]
    omega



/-- If a Kayleigh graph accepts a word then its position is dominated by the identity.
NOTE: More is true, it is sufficient that ``khδ` *process* the word. -/
theorem kayleighBound {A : Type*} {k : ℕ} {w : Fin (2 * k + 1) → A}
    {p : Fin (2 * k + 1 + 1) → Fin (k + 1)}
    (h : accepts_path (khδ' w) 0 0 p) :
    ∀ s : Fin (2*k+1+1), (p s).1 ≤ s.1 := by
  intro s
  exact @Fin.induction (2*k+1) (fun n => (p n).1 ≤ n.1)
    (by simp only [Fin.val_zero, nonpos_iff_eq_zero];rw [h.1];simp) (by
      intro n ih
      calc
      _ ≤ (p (n.castSucc)).1 + 1 := @move_slowly A k w p 0 h n
      _ ≤ n.castSucc + 1         := add_le_add_right ih 1
      _ ≤ _                      := le_refl (↑n.castSucc + 1)
    ) s


/-- A Kayleigh graph path does not retreat too fast. -/
theorem kayleighBound_lower {A : Type*} {k : ℕ} (w : Fin (2 * k + 1) → A)
    (p : Fin (2 * k + 1 + 1) → Fin (k + 1)) (h : accepts_path (khδ' w) 0 0 p)
    (s : Fin (2 * k + 1)) : (p s.succ).1 ≥ (p s.castSucc).1 - 1 :=
  @Fin.induction (2*k)
    (fun n : Fin (2*k+1) => (p n.castSucc).1 - 1 ≤ (p n.succ).1)
    (by simp only [Fin.castSucc_zero, Fin.succ_zero_eq_one, tsub_le_iff_right]; rw [h.1]; simp) (by
      intro n hn
      unfold accepts_path at h
      obtain ⟨a,ha⟩ := h.2.2 n.succ
      unfold khδ' δ_of_path at ha
      simp only [Fin.coe_eq_castSucc, Fin.coe_castSucc, Fin.val_succ, add_lt_add_iff_right,
        reduceSubDiff, Set.mem_setOf_eq] at ha
      obtain ⟨t,ht⟩ := ha
      by_cases h₀ : t.1 < k + 1
      · rw [dif_pos h₀] at ht
        by_cases h₁ : t.1 < k
        · rw [dif_pos h₁] at ht
          rw [← ht.1]
          rw [← ht.2.1] -- suspiciously similar to earlier proof...
          simp only [tsub_le_iff_right]
          omega
        · rw [dif_neg h₁] at ht
          rw [← ht.1]
          rw [← ht.2.1] -- suspiciously similar to earlier proof...
          simp only [tsub_le_iff_right]
          omega
      · rw [dif_neg h₀] at ht
        have h₁ : ¬ t.1 < k := by omega
        rw [dif_neg h₁] at ht
        rw [← ht.1, ← ht.2.1]
        simp only [tsub_le_iff_right, ge_iff_le]
        omega
    ) s

/-- If the Kayleigh graph ever uses the loop, we know when!
Same proof for khδ' as for khδ given earlier lemmas, so we could
generalize this.
-/
theorem hyde_loop_when {A : Type*} {k : ℕ} (w : Fin (2 * k + 1) → A)
    (p : Fin (2 * (k + 1)) → Fin (k + 1))
    (h : accepts_path (khδ' w) 0 0 p) (t : Fin (2 * k + 1))
    (ht : p t.castSucc = Fin.last k ∧ p t.succ = Fin.last k) :
    t = ⟨k, by omega⟩ := by
  by_contra H
  cases lt_or_gt_of_ne fun hc => H <| Fin.eq_mk_iff_val_eq.mpr hc with
  | inl h' =>
    have : (p t.castSucc).1 < k := by
      have h₁ : (p t.castSucc).1 ≤ t.castSucc := by
        apply kayleighBound; exact h
      simp only [Fin.coe_castSucc] at h₁
      calc
      _ ≤ _ := h₁
      _ < _ := h'
    rw [ht.1] at this
    simp at this
  | inr h' =>
  · have g₀ : t.1 < 2*k + 1 := by
      by_contra H
      have ht2 := t.2
      have ht : t.1 = 2*k+1 := by omega
      unfold accepts_path khδ' at h
      have := h.2.1
      rw [ht] at H
      have : p ⟨t.1,by omega⟩ = 0 := by
        rw [← this]; congr
      have : Fin.last k = 0 := by aesop
      have : k = 0 := Fin.last_eq_zero_iff.mp this
      omega
    have : ∀ s : Fin (2*k+1), (p s.succ).1 ≥ p s.castSucc - 1 := by
      apply kayleighBound_lower
      exact h
    have : ∀ s : Fin (2 * k+1 - t.1), (p (⟨t.1 + 1 + s, by omega⟩)).1 ≥ k - s := by
      intro s
      exact @Fin.induction (2*k-t.1)
        (fun n : Fin (2*k-t.1+1) =>
          (p (⟨t.1 + 1 + n, by omega⟩)).1 ≥ k - n ) (by
          apply le_of_eq;symm;have :=ht.2
          exact Fin.mk.inj_iff.mp this) (by
          intro i hi
          have h₁ := this ⟨t.1 + 1 + i.1, by omega⟩
          simp_all only [mul_eq, gt_iff_lt, Fin.is_lt, ge_iff_le, tsub_le_iff_right,
            Fin.coe_castSucc, Fin.succ_mk, Fin.castSucc_mk, Fin.val_succ]
          simp_rw [← add_assoc (t.1 + 1)]
          omega
        ) ⟨s.1, by omega⟩
    have h₃ := this ⟨2*k+1-(t.1+1), by omega⟩
    simp only [reduceSubDiff, ge_iff_le, tsub_le_iff_right] at h₃
    have h₀ :  1 ≤ (p ⟨t.1 + 1 + (2 * k - t.1), by omega⟩).1 := by omega
    have h₁ : t.1 + 1 + (2 * k - t.1) = 2*k+1 := by omega
    have h₂ :  1 ≤ (p (Fin.last (2*k+1))).1 := by
      simp_rw [h₁] at h₀
      exact h₀
    unfold accepts_path at h
    simp_all


/-- If a Kayleigh graph path never uses the loop, then it preserves parity. -/
theorem hyde_parity {A : Type*} {k : ℕ} (w : Fin (2 * k + 1) → A) (p : Fin (2 * (k + 1)) → Fin (k + 1))
    (h : accepts_path (khδ' w) 0 0 p)
    (H : ¬ ∃ t : Fin (2*k+1), p t.castSucc = Fin.last k ∧ p t.succ = Fin.last k) :
    ∀ (t : Fin (2 * (k + 1))), (p t).1 % 2 = t % 2 := by
  push_neg at H
  intro t
  exact @Fin.induction (2*k+1) (fun n => (p n).1 % 2 = n % 2)
    (by simp only [Fin.val_zero, zero_mod];rw [h.1];simp) (by
    intro n ih
    have ⟨a,h₁⟩ := h.2.2 n
    unfold khδ' δ_of_path at h₁
    simp only [Fin.coe_eq_castSucc, Fin.coe_castSucc, mul_eq, Fin.val_succ, add_lt_add_iff_right,
      reduceSubDiff, Set.mem_setOf_eq] at h₁
    obtain ⟨t,ht⟩ := h₁
    by_cases h₀ : t.1 < k + 1
    · rw [dif_pos h₀] at ht
      by_cases h₁ : t.1 < k
      · rw [dif_pos h₁] at ht
        rw [← ht.2.1]
        simp only [Fin.val_succ]
        have : t.1 % 2 = n.1 % 2 := by
          have : t.1 = (p n.castSucc).1 := by rw [← ht.1]
          rw [this, ih]
          simp
        exact add_mod_eq_add_mod_right 1 this
      · rw [dif_neg h₁] at ht
        rw [← ht.2.1]
        rw [← ht.1] at ih
        have : t.1 = k := by omega
        simp_rw [this] at ih ht ⊢
        have : 2 * k - k = k := by omega
        simp_rw [this] at ht ⊢
        have := H n (by
          rw [← ht.1]
          rfl
        ) ht.2.1.symm
        exact False.elim this
    · rw [dif_neg h₀] at ht
      have h₁ : ¬ t.1 < k := by omega
      rw [dif_neg h₁] at ht
      rw [← ht.1] at ih
      rw [← ht.2.1]
      simp only [Fin.coe_castSucc, Fin.val_succ] at ih ⊢
      have : 2 * k + 1 - t.1 = 2 * k - t.1 + 1 := by omega
      simp_rw [this] at ih
      have := add_mod_eq_add_mod_right 1 ih
      rw [← this]
      conv =>
        rhs
        arg 1
        change 2 * k - t.1 + 2
      exact Eq.symm (add_mod_right (2 * k - ↑t) 2)
    ) t

/-- A baffling auxiliary lemma about accepting paths in the Kayleigh graph NFA. -/
theorem move_slowly_rev_aux {A : Type*} {k : ℕ} (w : Fin (2 * k + 1) → A)
(p : Fin (2 * (k + 1)) → Fin (k + 1))
    (h : accepts_path (khδ' w) 0 0 p) (s : Fin k) :
    k ≤ k - (p ⟨s.1 + k + 1, by omega⟩).1 + 1
          + (p ⟨s.1 + 1 + k + 1, by omega⟩).1 := by
  suffices k ≤ k + 1 + (p ⟨s + 1 + k + 1, by omega⟩).1  - (p ⟨s + k + 1, by omega⟩).1 by omega
  simp_rw [show s + 1 + k + 1 = s + k + 1 + 1 by ring]
  have hmo' := @kayleighBound_lower A k w p h ⟨s + k + 1, by omega⟩
  simp only [Fin.succ_mk, Fin.castSucc_mk, ge_iff_le, tsub_le_iff_right] at hmo'
  have h : k + (1 + (p ⟨s + k + 1 + 1, by omega⟩).1 - (p ⟨s + k + 1, by omega⟩).1)
    = k + 1 + (p ⟨s + k + 1 + 1, by omega⟩).1 - (p ⟨s + k + 1, by omega⟩).1 := by
    apply Nat.eq_sub_of_add_eq'
    omega
  rw [← h]
  apply Nat.le_add_right


/-- The Kayleigh graph NFA for an odd-length word `w` accepts along only the intended path. -/
theorem hyde_unique_path {A : Type*} {k : ℕ} (w : Fin (2*k+1) → A)
  (p : Fin (2*(k+1)) → Fin (k+1))
  (h : accepts_path (khδ' w) 0 0 p) :
  p = fun t : Fin (2*(k+1)) => dite (t.1 < k + 1) (⟨t.1, .⟩) (⟨2*k+1-t.1, flipCast .⟩)  := by
  by_cases H : ∃ t : Fin (2*k+1), p t.castSucc = Fin.last k ∧ p t.succ = Fin.last k -- we use the loop
  · obtain ⟨t,ht⟩ := H
    have : t = ⟨k,by omega⟩ := by apply hyde_loop_when <;> tauto
    ext s
    split_ifs with g₀
    · by_cases hh : s.1 = k
      · have : s = ⟨k, by omega⟩ := Fin.eq_of_val_eq hh
        aesop
      have h₀':= @exact_racecar k (fun x => p ⟨x.1,by have := x.2;linarith⟩)
        (by
          simp only [Fin.val_zero, Fin.zero_eta]
          exact h.1) (by aesop)
        (by
          intro s;simp only [Fin.val_succ, Fin.coe_castSucc]
          exact @move_slowly A k w p 0 h (s.castLT (by omega))
        ) ⟨s, by omega⟩
      simp only [Fin.castSucc_mk, Fin.eta] at h₀'
      rw [h₀']
    · -- the same as the other case but in opposite order...
      rw [this] at ht
      simp only [not_lt] at g₀
      by_cases hh : s.1 = 2 * k + 1
      · simp_rw [hh]
        simp only [Nat.sub_self]
        have h₀ : s = Fin.last (2*k+1) := Fin.eq_of_val_eq hh
        rw [h₀]
        exact Fin.mk.inj_iff.mp h.2.1

      · let f : Fin ((k+1)) → Fin ((k+1)) :=
          fun u  => ⟨k - (p ⟨u + k + 1,by omega⟩).1, by omega⟩

        simp only
        suffices (f ⟨s.1 - (k+1),by omega⟩).1 = s.1 - (k+1) by
          have h₀ : s.1 - (k+1) + k + 1 = s.1 := by omega
          simp_rw [h₀] at this
          change k - (p s).1 = s.1 - (k+1) at this
          omega
        have := @exact_racecar k f (by
          unfold f;
          simp_all
        ) (by
          unfold f;
          unfold accepts_path at h
          have := h.2.1
          simp only [mul_eq] at this
          simp only [Fin.val_last]
          simp_rw [← two_mul]
          apply Fin.mk.inj_iff.mpr
          show  k - (p (Fin.last (2*k+1))).1 = k
          rw [this]
          simp
          ) (by
            intro s₁
            rw [tsub_le_iff_right]
            apply move_slowly_rev_aux <;> tauto
          ) ⟨s - (k+1), by omega⟩
        unfold f at this
        simp only [Fin.castSucc_mk, Fin.mk.injEq] at this
        exact this
  · have : ∀ (t : Fin (2 * (k+1))), (p t).1 % 2 = t % 2 := by
      apply hyde_parity <;> tauto

    have : p (Fin.last (2*k+1)) ≠ 0 := by
      intro hc
      have := this (Fin.last (2*k+1))
      rw [hc] at this
      revert this
      intro hc
      symm at hc
      revert hc
      simp only [Fin.val_last, Fin.val_zero, zero_mod, imp_false, mod_two_ne_zero]
      apply succ_mod_two_eq_one_iff.mpr
      simp
    exfalso
    unfold accepts_path at h
    tauto


/-- The Kayleigh graph NFA for an odd-length word `w` accepts along only the intended path,
 no matter what word `v` with `|v| = |w|` is read. -/
theorem hyde_unique_path_reading_word' {A : Type*} {k : ℕ} {w v : Fin (2*k+1) → A}
  {p : Fin (2*(k+1)) → Fin (k+1)}
  (h : accepts_word_path (khδ' w) v 0 0 p) :
  p = fun t => dite (t.1 < k + 1) (⟨t.1, . ⟩) (⟨2*k+1-t.1,flipCast .⟩)  := by
  apply hyde_unique_path
  apply accepts_path_of_accepts_word_path <;> tauto

/-- The Kayleigh graph NFA for `w` accepts no word of length `|w|` other than `w`. -/
theorem hyde_unique_word' {A : Type*} {k : ℕ} {w v : Fin (2*k+1) → A}
    {p : Fin (2*(k+1)) → Fin (k+1)}
    (ha : accepts_word_path (khδ' w) v 0 0 p) :
    w = v := by
  ext ⟨i,hi⟩
  have hup := hyde_unique_path_reading_word' ha
  subst hup
  unfold accepts_word_path at ha
  unfold khδ' δ_of_path at ha
  simp only [Fin.val_zero, lt_add_iff_pos_left, add_pos_iff, zero_lt_one, or_true, ↓reduceDIte,
    Fin.zero_eta, Fin.val_last, add_lt_add_iff_right, Nat.sub_self, dite_eq_right_iff,
    Fin.coe_eq_castSucc, Fin.coe_castSucc, Fin.val_succ, reduceSubDiff, Set.mem_setOf_eq,
    true_and] at ha
  have h₂ := ha.2 ⟨i, hi⟩
  clear ha
  obtain ⟨t,ht⟩ := h₂
  split_ifs at ht with g₀ g₁ g₂ g₃ g₄ g₅ g₆ g₇ g₈ g₉ g₁₀ g₁₁ g₁₂ g₁₃
  · have this : i = t.1 := by aesop
    subst this
    exact ht.2.2
  · have this : i = t.1 := by aesop
    subst this
    exact ht.2.2
  · have this : i = t.1 := by aesop
    subst this
    exact ht.2.2
  · have this : i = t.1 := by aesop
    subst this
    exact ht.2.2
  · have this : i = t.1 := by
      have := ht.2.1
      simp only [Fin.mk.injEq, add_left_inj] at this
      rw [this]
    subst this
    exact ht.2.2
  · have : i = k := by
      simp_all only [Fin.mk.injEq]
      omega
    subst this
    have := ht.1
    simp only [Fin.mk.injEq] at this
    omega
  · omega
  · have : 2 * k - t = 2 * k - i := by
      have := ht.2.1
      simp only [Fin.mk.injEq] at this
      exact this
    simp only [not_lt] at g₁
    omega
  · have this : i = t.1 := by aesop
    subst this
    exact ht.2.2
  · have : i = k := by omega
    subst this
    have := ht.1
    omega
  · simp only [Fin.mk.injEq] at ht
    omega
  · simp only [Fin.mk.injEq] at ht
    omega
  · have this : i = t.1 := by aesop
    subst this
    exact ht.2.2
  · omega
  · omega
  · simp only [Fin.mk.injEq, not_lt] at ht g₀ g₈
    have this : i = t.1 := by omega
    subst this
    exact ht.2.2



/-- δ_of_path works as intended. -/
theorem δ_of_path_works_as_intended' {A Q : Type*} {n : ℕ} (w : Fin n → A) (p : Fin (n+1) → Q) :
    (accepts_word_path (δ_of_path w p) w (p 0) (p (Fin.last n)) p) := by
  unfold accepts_word_path
  constructor
  · rfl
  · constructor
    · rfl
    · intro i
      unfold δ_of_path
      simp
      use i

/- The Kayleigh graph NFA for `w` accepts `w` along the intended path. -/
theorem hyde_accepts {A : Type*} {k : ℕ}  (w : Fin (2*k+1) → A) :
    accepts_word_path (khδ' w) w 0 0 fun t => dite (t.1 < k + 1) (⟨t.1, .⟩) (⟨2*k+1-t.1,flipCast .⟩) := by
  have := @δ_of_path_works_as_intended' A (Fin (k+1)) (2*k+1) w fun t : Fin (2*k+1+1)=>
    dite (t.1 < k + 1) (fun ht => (⟨t.1, ht⟩ : Fin (k+1))) (fun ht => ⟨2*k+1-t.1,flipCast ht⟩)
  simp [khδ'] at this
  revert this
  apply Iff.mp
  apply Eq.to_iff
  congr
  simp
  intro
  omega



/-- Hyde's theorem for odd-length words. -/
theorem hydetheorem_odd' {A : Type*} {k : ℕ} (w : Fin (2*k+1) → A) :
 A_N_at_most w (k+1) := by
 use Fin (k+1), Fin.fintype (k + 1)
 constructor
 · exact Fintype.card_fin (k + 1)
 · use khδ' w, 0, 0, fun t : Fin (2*(k+1)) => dite (t.1 < k + 1)
    (fun ht => (⟨t.1,     ht⟩ : Fin (k+1)))
    (fun ht => (⟨2*k+1-t.1,flipCast ht⟩ : Fin (k+1)))
   constructor
   · exact hyde_accepts w
   · exact fun _ _ h => ⟨(hyde_unique_path_reading_word' h).symm, hyde_unique_word' h⟩


/-- Hyde's theorem for positive-length words. -/
theorem hyde_pos_length {A : Type*} {n : ℕ} (hn : n ≠ 0) (w : Fin n → A) :
A_N_at_most w (n/2+1) := by
  by_cases he : Odd n
  · obtain ⟨k,hk⟩ := he
    subst hk
    have : (2 * k + 1) / 2 + 1 = k + 1 := by omega
    exact this ▸ hydetheorem_odd' _
  · simp only [not_odd_iff_even] at he
    obtain ⟨k, hk⟩ := he
    rw [← two_mul] at hk
    subst hk
    have : (2 * k)/2 + 1 = k + 1 := by omega
    rw [this]
    have a := (Classical.inhabited_of_nonempty <| (Nonempty.intro <| w ⟨0,by omega⟩)).default
    let w' := @Fin.snoc (2*k) (fun _ => A) w a
    exact (Fin.init_snoc _ _) ▸ restricting <| hydetheorem_odd' w'

/-- Hyde's theorem in relational form. -/
theorem hyde_all_lengths {A : Type*} {n : ℕ} (w : Fin n → A) :
    A_N_at_most w (n/2+1) := by
  by_cases H : n = 0
  · subst H
    exact hyde_emp w
  · exact hyde_pos_length H w

/-- A_N is well-defined. -/
theorem A_N_bounded {A : Type*} {n : ℕ} (w : Fin n → A) :
  ∃ q, A_N_at_most w q := by
  use n/2+1
  apply hyde_all_lengths

/-- Nondeterministic automatic complexity. -/
noncomputable def A_N {A : Type*} : {n : ℕ} → (Fin n → A) → ℕ :=
  fun w => Nat.find (A_N_bounded w)

/-- Hyde's theorem (2013). -/
theorem A_N_bound {A : Type*} {n : ℕ} (w : Fin n → A) :
  A_N w ≤ n/2+1 := find_le <| hyde_all_lengths w
-- end of Hyde


theorem A_Ne_bounded {A : Type} {n : ℕ} (w : Fin n → A) :
  ∃ q, A_Ne_at_most w q := by
  use n/2+1
  exact A_Ne_le_A_N <| hyde_all_lengths w

/-- Exact nondeterministic automatic complexity. -/
noncomputable def A_Ne {A : Type} : {n : ℕ} → (Fin n → A) → ℕ :=
  fun w => Nat.find (A_Ne_bounded w)
